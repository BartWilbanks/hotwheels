<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Multiplayer Track Racer (Host)</title>
  <style>
    body { margin:0; font-family: system-ui, Arial; background:#0b1220; color:#fff; }
    #topbar {
      display:flex; gap:10px; align-items:center; padding:10px;
      background:#0a2342; position:sticky; top:0;
      flex-wrap:wrap;
    }
    button, select, input {
      padding:8px 10px; border-radius:10px; border:0; cursor:pointer;
    }
    input { cursor:text; }
    button { background:#6bbf59; color:#0a2342; font-weight:800; }
    button.secondary { background:#1b2b4a; color:#fff; font-weight:700; }
    #wrap { display:flex; gap:10px; padding:10px; align-items:flex-start; }
    #canvas { background:#0f1a2f; border-radius:14px; }
    #panel {
      width:360px; max-width:360px;
      background:#111c34; border-radius:14px; padding:12px;
      line-height:1.35;
    }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#1b2b4a; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:6px 0; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    small { opacity:.85; }
    a { color:#cbe6ff; }
  </style>
</head>
<body>
  <div id="topbar">
    <span style="font-weight:900">Host</span>
    <span class="pill">Track Builder + Multiplayer</span>

    <label class="row" style="margin:0">
      Piece:
      <select id="piece">
        <option value="empty">Eraser</option>
        <option value="straight">Straight</option>
        <option value="curve">Curve</option>
      </select>
    </label>

    <label class="row" style="margin:0">
      Rotation:
      <select id="rot">
        <option value="0">0°</option>
        <option value="1">90°</option>
        <option value="2">180°</option>
        <option value="3">270°</option>
      </select>
    </label>

    <button id="clear">Clear Track</button>
    <button class="secondary" id="toggleMode">Toggle Drive Mode</button>
    <button class="secondary" id="resetCars">Reset Cars</button>
  </div>

  <div id="wrap">
    <canvas id="canvas" width="980" height="620"></canvas>

    <div id="panel">
      <div style="font-weight:900; margin-bottom:6px;">Room</div>

      <div class="row">
        <button id="createRoom">Create Room</button>
        <span id="roomCode" class="pill mono">----</span>
      </div>

      <div class="row">
        <span>Controller URL:</span>
        <span id="controllerUrl" class="mono" style="word-break:break-all; opacity:.95;"></span>
      </div>

      <div class="row">
        <button class="secondary" id="copyLink">Copy Link</button>
        <small id="copyStatus"></small>
      </div>

      <hr style="border:0; border-top:1px solid rgba(255,255,255,.12); margin:10px 0;">

      <div style="font-weight:900; margin-bottom:6px;">Players</div>
      <div id="players"></div>

      <hr style="border:0; border-top:1px solid rgba(255,255,255,.12); margin:10px 0;">

      <div style="font-weight:900; margin-bottom:6px;">How it works</div>
      <ul style="margin:6px 0 0 18px; padding:0;">
        <li>Click <b>Create Room</b> → share the controller link.</li>
        <li>Players open it on phones, enter name, and join.</li>
        <li>Build track in <b>Build mode</b>.</li>
        <li>Toggle to <b>Drive mode</b> and race.</li>
      </ul>
      <small>
        Tip: put the host screen on a TV via HDMI and let phones be controllers.
      </small>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const GRID_W = 28, GRID_H = 18;
  const TILE = 34;
  const ORIGIN_X = 14, ORIGIN_Y = 14;

  const pieceSel = document.getElementById('piece');
  const rotSel = document.getElementById('rot');
  const btnClear = document.getElementById('clear');
  const btnToggleMode = document.getElementById('toggleMode');
  const btnResetCars = document.getElementById('resetCars');

  const btnCreateRoom = document.getElementById('createRoom');
  const roomCodeEl = document.getElementById('roomCode');
  const controllerUrlEl = document.getElementById('controllerUrl');
  const btnCopyLink = document.getElementById('copyLink');
  const copyStatus = document.getElementById('copyStatus');
  const playersEl = document.getElementById('players');

  // Track grid
  const grid = Array.from({length: GRID_H}, () =>
    Array.from({length: GRID_W}, () => ({ type:'empty', rot:0 }))
  );

  // Game state
  let driveMode = false;

  // Multiplayer
  let ws = null;
  let roomCode = null;
  const players = new Map(); // playerId -> {id,name,color,car:{x,y,a,v,inputs}}
  const COLORS = ['#6bbf59','#ffcc66','#66ccff','#ff6699','#c8a6ff','#ff9966','#9cff99','#ffd1dc'];

  // Simple host car physics
  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

  // road check (same approach as prototype)
  function pointToCell(x,y){
    const gx = Math.floor((x - ORIGIN_X)/TILE);
    const gy = Math.floor((y - ORIGIN_Y)/TILE);
    if (gx<0||gy<0||gx>=GRID_W||gy>=GRID_H) return null;
    return {gx,gy};
  }

  function isOnRoad(px, py, cellOverride=null){
    const c = pointToCell(px,py);
    if (!c) return false;
    const cell = cellOverride ?? grid[c.gy][c.gx];
    if (!cell || cell.type === 'empty') return false;

    const cx = ORIGIN_X + c.gx*TILE;
    const cy = ORIGIN_Y + c.gy*TILE;
    let lx = px - (cx + TILE/2);
    let ly = py - (cy + TILE/2);

    const r = (cell.rot % 4) * Math.PI/2;
    const cos = Math.cos(-r), sin = Math.sin(-r);
    const rx = lx*cos - ly*sin;
    const ry = lx*sin + ly*cos;

    const x = rx + TILE/2;
    const y = ry + TILE/2;

    const w = TILE*0.42;
    const x0 = TILE/2 - w/2, x1 = TILE/2 + w/2;

    if (cell.type === 'straight'){
      return (x >= x0 && x <= x1);
    }
    if (cell.type === 'curve'){
      const inVert = (x >= x0 && x <= x1 && y <= TILE/2 + 1);
      const inHoriz = (y >= x0 && y <= x1 && x >= TILE/2 - 1);
      return inVert || inHoriz;
    }
    return false;
  }

  function drawGrid(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#0f1a2f';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    for (let y=0;y<GRID_H;y++){
      for (let x=0;x<GRID_W;x++){
        const px = ORIGIN_X + x*TILE;
        const py = ORIGIN_Y + y*TILE;
        ctx.fillStyle = '#132445';
        ctx.fillRect(px, py, TILE-1, TILE-1);

        const cell = grid[y][x];
        if (cell.type !== 'empty') drawPiece(px, py, cell);
      }
    }
  }

  function drawPiece(px, py, cell){
    const road = '#2a3d66';
    const edge = '#7aa7ff';

    ctx.save();
    ctx.translate(px + TILE/2, py + TILE/2);
    ctx.rotate(cell.rot * Math.PI/2);
    ctx.translate(-TILE/2, -TILE/2);

    ctx.fillStyle = road;
    ctx.strokeStyle = edge;
    ctx.lineWidth = 2;

    if (cell.type === 'straight'){
      const w = TILE*0.42;
      ctx.fillRect(TILE/2 - w/2, 0, w, TILE);
      ctx.strokeRect(TILE/2 - w/2, 0, w, TILE);
    } else if (cell.type === 'curve'){
      const w = TILE*0.42;
      ctx.fillRect(TILE/2 - w/2, 0, w, TILE/2 + 1);
      ctx.strokeRect(TILE/2 - w/2, 0, w, TILE/2 + 1);
      ctx.fillRect(TILE/2, TILE/2 - w/2, TILE/2 + 1, w);
      ctx.strokeRect(TILE/2, TILE/2 - w/2, TILE/2 + 1, w);

      ctx.beginPath();
      ctx.arc(TILE/2, TILE/2, TILE*0.30, -Math.PI/2, 0);
      ctx.stroke();
    }

    ctx.restore();
  }

  function drawCar(car, name){
    ctx.save();
    ctx.translate(car.x, car.y);
    ctx.rotate(car.a);
    ctx.fillStyle = car.color;
    ctx.beginPath();
    ctx.roundRect(-10, -6, 20, 12, 4);
    ctx.fill();
    ctx.fillStyle = '#cbe6ff';
    ctx.fillRect(0, -4, 7, 8);
    ctx.restore();

    // label
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.font = '700 12px system-ui';
    ctx.fillText(name, car.x - 14, car.y - 12);
  }

  function resetAllCars(){
    let i = 0;
    for (const p of players.values()){
      const lane = i % 6;
      p.car.x = ORIGIN_X + TILE*4 + TILE/2;
      p.car.y = ORIGIN_Y + TILE*(4 + lane) + TILE/2;
      p.car.a = 0;
      p.car.v = 0;
      i++;
    }
  }

  function tick(){
    // physics for each player's car based on their inputs
    if (driveMode){
      for (const p of players.values()){
        const inp = p.car.inputs;
        const accel = inp.up ? 0.18 : (inp.down ? -0.14 : 0);
        const steer = (inp.left ? -1 : 0) + (inp.right ? 1 : 0);

        p.car.v += accel;
        p.car.v = clamp(p.car.v, -2.2, 3.2);

        p.car.a += steer * (0.045 + Math.min(Math.abs(p.car.v), 3)*0.01);

        const onRoad = isOnRoad(p.car.x, p.car.y);
        const fric = onRoad ? 0.985 : 0.93;
        p.car.v *= fric;

        p.car.x += Math.cos(p.car.a) * p.car.v;
        p.car.y += Math.sin(p.car.a) * p.car.v;

        p.car.x = clamp(p.car.x, ORIGIN_X, ORIGIN_X + GRID_W*TILE);
        p.car.y = clamp(p.car.y, ORIGIN_Y, ORIGIN_Y + GRID_H*TILE);
      }
    }

    drawGrid();

    // draw cars
    for (const p of players.values()){
      drawCar(p.car, p.name);
    }

    // footer label
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.font = '700 14px system-ui';
    ctx.fillText(driveMode ? 'DRIVE MODE (players use phone controls)' : 'BUILD MODE (click to place)', 16, canvas.height - 14);

    requestAnimationFrame(tick);
  }

  // Build mode placement
  canvas.addEventListener('click', (e) => {
    if (driveMode) return;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);

    const c = pointToCell(x,y);
    if (!c) return;

    grid[c.gy][c.gx] = { type: pieceSel.value, rot: Number(rotSel.value) };

    // broadcast track update to controllers (optional; for preview)
    send({ t:'track', room: roomCode, grid });
  });

  btnClear.onclick = () => {
    for (let y=0;y<GRID_H;y++) for (let x=0;x<GRID_W;x++) grid[y][x] = {type:'empty', rot:0};
    send({ t:'track', room: roomCode, grid });
  };

  btnToggleMode.onclick = () => {
    driveMode = !driveMode;
    send({ t:'mode', room: roomCode, driveMode });
  };

  btnResetCars.onclick = () => {
    resetAllCars();
    send({ t:'state', room: roomCode, players: serializePlayers() });
  };

  // Room / WS
  function wsUrl(){
    // Render terminates TLS. Use wss:// in production.
    const proto = (location.protocol === 'https:') ? 'wss:' : 'ws:';
    return `${proto}//${location.host}/ws`;
  }

  function connectWs(){
    return new Promise((resolve, reject) => {
      ws = new WebSocket(wsUrl());
      ws.onopen = () => resolve();
      ws.onerror = (e) => reject(e);
      ws.onmessage = (ev) => {
        const msg = JSON.parse(ev.data);
        handle(msg);
      };
      ws.onclose = () => {
        // try simple reconnect
        setTimeout(() => {
          if (roomCode) connectWs().then(() => send({t:'host-rejoin', room: roomCode})).catch(()=>{});
        }, 800);
      };
    });
  }

  function send(obj){
    if (!ws || ws.readyState !== 1) return;
    ws.send(JSON.stringify(obj));
  }

  function serializePlayers(){
    return Array.from(players.values()).map(p => ({
      id: p.id, name: p.name, color: p.color,
      car: { x:p.car.x, y:p.car.y, a:p.car.a, v:p.car.v }
    }));
  }

  function setPlayersUi(){
    if (!roomCode){
      playersEl.innerHTML = '<small>Room not created yet.</small>';
      return;
    }
    if (players.size === 0){
      playersEl.innerHTML = '<small>No players yet — share the controller link.</small>';
      return;
    }
    const rows = [];
    for (const p of players.values()){
      rows.push(`
        <div class="row" style="justify-content:space-between;">
          <span><span class="pill" style="background:${p.color}; color:#0b1220; font-weight:900;">&nbsp;</span> <b>${escapeHtml(p.name)}</b></span>
          <span class="mono" style="opacity:.8;">${p.id.slice(0,6)}</span>
        </div>
      `);
    }
    playersEl.innerHTML = rows.join('');
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  function handle(msg){
    if (!msg || !msg.t) return;

    if (msg.t === 'room-created'){
      roomCode = msg.room;
      roomCodeEl.textContent = roomCode;

      const controllerUrl = `${location.origin}/controller.html?room=${encodeURIComponent(roomCode)}`;
      controllerUrlEl.textContent = controllerUrl;

      setPlayersUi();
      send({ t:'track', room: roomCode, grid });
      send({ t:'mode', room: roomCode, driveMode });
      return;
    }

    if (msg.t === 'player-joined'){
      // create player on host
      const color = COLORS[players.size % COLORS.length];
      const id = msg.playerId;
      const name = msg.name || 'Player';
      players.set(id, {
        id, name, color,
        car: {
          x: ORIGIN_X + TILE*4 + TILE/2,
          y: ORIGIN_Y + TILE*(4 + (players.size % 6)) + TILE/2,
          a: 0, v: 0, color,
          inputs: {up:false,down:false,left:false,right:false}
        }
      });
      setPlayersUi();
      // send state to all controllers (so they can show roster)
      send({ t:'state', room: roomCode, players: serializePlayers() });
      return;
    }

    if (msg.t === 'player-left'){
      players.delete(msg.playerId);
      setPlayersUi();
      send({ t:'state', room: roomCode, players: serializePlayers() });
      return;
    }

    if (msg.t === 'input' && msg.playerId){
      const p = players.get(msg.playerId);
      if (!p) return;
      p.car.inputs = msg.inputs || p.car.inputs;
      return;
    }

    if (msg.t === 'host-rejoined' && msg.players){
      // rebuild roster after reconnect (server is source of player list)
      players.clear();
      for (const pl of msg.players){
        const color = COLORS[players.size % COLORS.length];
        players.set(pl.playerId, {
          id: pl.playerId,
          name: pl.name || 'Player',
          color,
          car: {
            x: ORIGIN_X + TILE*4 + TILE/2,
            y: ORIGIN_Y + TILE*(4 + (players.size % 6)) + TILE/2,
            a: 0, v: 0, color,
            inputs: {up:false,down:false,left:false,right:false}
          }
        });
      }
      setPlayersUi();
      send({ t:'state', room: roomCode, players: serializePlayers() });
      send({ t:'track', room: roomCode, grid });
      send({ t:'mode', room: roomCode, driveMode });
      return;
    }
  }

  btnCreateRoom.onclick = async () => {
    copyStatus.textContent = '';
    if (!ws || ws.readyState !== 1){
      await connectWs();
    }
    send({ t:'create-room' });
  };

  btnCopyLink.onclick = async () => {
    const url = controllerUrlEl.textContent?.trim();
    if (!url) return;
    try{
      await navigator.clipboard.writeText(url);
      copyStatus.textContent = 'Copied!';
      setTimeout(()=>copyStatus.textContent='', 1200);
    }catch{
      copyStatus.textContent = 'Copy failed (browser blocked).';
    }
  };

  // sample track
  function place(x,y,type,rot){ grid[y][x] = {type,rot}; }
  place(4,4,'straight',1); place(5,4,'straight',1); place(6,4,'curve',1);
  place(6,5,'straight',0); place(6,6,'curve',2);
  place(5,6,'straight',1); place(4,6,'curve',3);
  place(4,5,'straight',0);

  // Polyfill for roundRect if needed
  if (!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      this.closePath();
      return this;
    }
  }

  // initial UI
  setPlayersUi();
  tick();
})();
</script>
</body>
</html>
